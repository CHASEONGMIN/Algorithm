# 카운팅정렬

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

1. **제한사항**
- 정수나, 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야한다.

2. **시간복잡도**

- O(n+k) : n은 리스트의 길이, k는 정수의 최대값

3. **구현 방법**

```python
def Counting_sort(A, k): # A: list, k: A의 최대값(알고있는 경우)
	counter = [0] * k
	B = list(A) # 정렬한 값을 담을 B, A와 길이가 같기때문에 복사해두기
	
	for i in range(len(A)): # A의 원소 count
		counter[A[i]] += 1 # 원소의 값에 맞는 counter의 해당 인덱스 값을 +1

	for i in range(1, len(C)): # 누적합을 더해 정렬을 위한 인덱스 조정
		counter[i] += counter[i-1]

	for i in range(len(A)-1, -1, -1): # 뒤에서부터 처음까지
		B[C[A[i]]] = A[i] # A[i]가 몇번째 자리로 가야하는지 찾아서, 그자리에 넣어주기
		C[A[i]] -= 1 # 인덱스 조정을 위해 자리를 할당했으니, count를 내려주기
```
