## 목차

### 1. 배열

#### - 완전탐색  (순열과 조합 포함)

#### - 그리디 알고리즘

#### - 정렬

- 버블 정렬

- 카운팅 정렬

- 선택 정렬

- 퀵 정렬

- 삽입 정렬

- 병합 정렬

#### - 검색

- 순차탐색
  
  - 정렬되어 있지 않으면 O(n), 정렬되어 있다면 O(n)

- 이진탐색 (정렬이 되어있어야만 가능)

- 해쉬

#### 이차원 배열 활용

#### 번외

- 부분집합 (다중 조건문 or 비트연산자)

### 2. 문자열

#### 기본

- 역순 정렬

- 비교

#### 문자열 -> 숫자   /   숫자 -> 문자열   (아스키 코드 활용)

#### 패턴

- 브루트 포스  (시간복잡도 N*M)

- KMP 알고리즘 (시간복잡도 N)
불일치가 발생한 텍스트 스트링의 앞부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞부분에 대하야 다시 비교하지 않고 매칭을 수행
패턴을 전처리 하여 배열 next[M]을 구해서 잘못된 시작을 최소화함

- 보이어-무어 알고리즘 (시간복잡도 N)
오른쪽에서 왼쪽으로 비교
대부분의 상용소프트웨어에서 채택하고 있는 알고리즘

#### 문자열 압축

예시 )
https://velog.io/@devjuun_s/%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4python2020-Kakao-%EA%B3%B5%EC%B1%84

### 3. 스택 (LIFO)

#### 재귀적 활용

#### 메모이제이션 활용 (DP 핵심)  - 재귀적 구조

- 한번 구해진 값에 대해서는 함수 호출없이 배열에서 값을 꺼내 계산을 진행하여 중복을 줄임.

예시)
```
def fibo1(n):
		global arr
		if n >= 2 and len(arr) <= n:
				arr.append(fibo1(n-1) + fibo1(n-2))
		return arr[n]
arr = [0, 1]
```

#### DP - 반복적 구조 (성능면에서 보다 효율적)

예시)
```
def fibo2(n):
		f = [0, 1]
		for i in range(2, n + 1):
				f.append(f[i-1] + f[i-2])
		return f[n]
```

#### DFS (깊이 우선 탐색)

- 백트래킹 활용(시도 횟수를 줄여주어 효율 상승)

+ 백트래킹 기법을 활용할 수 있는 문제 예시) 미로찾기, 체스, 부분집합, 순열 등

### 4. 큐

### 5. 트리
